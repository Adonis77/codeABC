# 回溯算法

## 算法关键思路：
* 解释：回溯法（back tracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

* 考虑树结构（排列树，子集树，组合树等），画出简图，根据简图来写代码
* 考虑需要剪枝的条件，控制进入下一层递归；
* 考虑满足什么条件时结束递归，得到一条解；
* 技巧：递归函数中一般可传递两个参数，临时结果和可选择数字集合

## LeetCode算法题

[60.第k个排列](https://leetcode-cn.com/problems/permutation-sequence/)

思路：
* 构建排列树，关键在于剪枝，排除对一部分节点的递归计算。因为最终结果肯定在
叶子节点上，可以得到当前分支的排列数上界。
* 注：目标值k在每次剪枝后更新
```
class Solution:
    #剪枝操作，若当前分支最多排列数小于当前目标位置k，剪枝；否则进入下一层
    def getPermutation(self, n: int, k: int) -> str:
        # 阶乘辅助函数
        def fact(n):
            res = 1
            while n > 1:
                res *= n
                n -= 1
            return res
        
        # 不断从剩余排列集合nums中选择数字加入到tmp
        def helper(tmp, nums, k):
            if not nums:
                return tmp
            
            a = fact(len(nums)-1)# 当前每个分支所包括的最多排列数
            for i in range(len(nums)):
                if a >= k:
                    return helper(tmp+str(nums[i]), nums[:i]+nums[i+1:], k)
                else:# 最多排列数小于k，剪枝，更新目标值k
                    k -= a
        
        nums = [i+1 for i in range(n)]
        return helper("", nums, k)
```
[216.组合总和3](https://leetcode-cn.com/problems/combination-sum-iii/submissions/)

思路：
* 为了满足题目中没有重复组合，构建组合树（构建分支节点时只使用比当前节点大的数字，与排列树不同）。
* 在剪枝时因为数字从小到大排列，使用break将后续所有分支全部剪掉。
* 也可以不使用s，而是传递k进去并在进入下一层递归时更新
```
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        res = []
        #构建组合树，tmp临时组合，start可选数字起始位置，s当前tmp和
        def helper(tmp, start, s):
            if len(tmp) == k:
                if s == n:
                    res.append(tmp)
                return
            for i in range(start, 10):
                if s+i > n:#加上当前数字后超过n，之后的都不考虑
                    break
                else:#下一层递归
                    helper(tmp+[i], i+1, s+i)#start是tmp中最大位置之后
        helper([], 1, 0)
        return res
```
[77.组合](https://leetcode-cn.com/problems/combinations/)

思路：
* 使用tmp表示临时组合，在每个数字节点递归遍历过后，从tmp中删除进行回溯
* 剪枝操作，当剩余可选数字不够后，不进行下一层递归
```
class Solution {
    // 不是成员变量？
    List<List<Integer>> res = new LinkedList();
    //回溯，构建组合树
    public List<List<Integer>> combine(int n, int k) {
        helper(new LinkedList<Integer>(), 1, k, n);
        return res;
    }
    // tmp表示临时组合，必须是LinkedList类型，不能定义为Liststart；start表示组合中下一个数起始位置
    public void helper(LinkedList<Integer> tmp, int start, int k, int n){
        if (tmp.size() == k){
            // 要新建一个linkedlist
            res.add(new LinkedList(tmp));
            return;
        }
        // 增加剪枝操作,剩余可选数字不够时剪掉
        for(int i=start;i<=n-(k-tmp.size())+1;i++){
            tmp.add(i);
            helper(tmp, i+1, k, n);
            // 回溯操作
            tmp.removeLast();
        }
    }
}
```
