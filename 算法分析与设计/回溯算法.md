# 回溯算法

## 算法关键思路：

* 考虑树结构（排列树，子集树，组合树等），画出简图，根据简图来写代码
* 考虑需要剪枝的条件，控制进入下一层递归；
* 考虑满足什么条件时结束递归，得到一条解；
* 技巧：递归函数中一般可传递两个参数，临时结果和可选择数字集合

## LeetCode算法题

[60.第k个排列](https://leetcode-cn.com/problems/permutation-sequence/)

思路：
* 构建排列树，关键在于剪枝，排除对一部分节点的递归计算。因为最终结果肯定在
叶子节点上，可以得到当前分支的排列数上界。
* 注：目标值k在每次剪枝后更新
```
class Solution:
    #剪枝操作，若当前分支最多排列数小于当前目标位置k，剪枝；否则进入下一层
    def getPermutation(self, n: int, k: int) -> str:
        # 阶乘辅助函数
        def fact(n):
            res = 1
            while n > 1:
                res *= n
                n -= 1
            return res
        
        # 不断从剩余排列集合nums中选择数字加入到tmp
        def helper(tmp, nums, k):
            if not nums:
                return tmp
            
            a = fact(len(nums)-1)# 当前每个分支所包括的最多排列数
            for i in range(len(nums)):
                if a >= k:
                    return helper(tmp+str(nums[i]), nums[:i]+nums[i+1:], k)
                else:# 最多排列数小于k，剪枝，更新目标值k
                    k -= a
        
        nums = [i+1 for i in range(n)]
        return helper("", nums, k)
```
[216.组合总和3](https://leetcode-cn.com/problems/combination-sum-iii/submissions/)

思路：
* 为了满足题目中没有重复组合，构建组合树（构建分支节点时只使用比当前节点大的数字，与排列树不同）。
* 在剪枝时因为数字从小到大排列，使用break将后续所有分支全部剪掉。
* 也可以不使用s，而是传递k进去并在进入下一层递归时更新
```
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        res = []
        #构建组合树，tmp临时组合，start可选数字起始位置，s当前tmp和
        def helper(tmp, start, s):
            if len(tmp) == k:
                if s == n:
                    res.append(tmp)
                return
            for i in range(start, 10):
                if s+i > n:#加上当前数字后超过n，之后的都不考虑
                    break
                else:#下一层递归
                    helper(tmp+[i], i+1, s+i)#start是tmp中最大位置之后
        helper([], 1, 0)
        return res
```
